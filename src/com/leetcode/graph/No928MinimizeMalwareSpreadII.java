package com.leetcode.graph;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class No928MinimizeMalwareSpreadII {
    // https://leetcode.com/problems/minimize-malware-spread-ii/discuss/184645/Straightforward-DFS-Java-6-ms
    public int minMalwareSpread(int[][] graph, int[] initial) {
        final Set<Integer> malware = new HashSet<>();
        for (int i : initial) malware.add(i);

        Arrays.sort(initial);
        int node = -1, max = -1;
        for (int n : initial) {
            final Set<Integer> visited = new HashSet<>();
            visited.add(n);

            int total = 0;
            for (int i = 0; i < graph.length; i++) {
                if (n == i || graph[n][i] != 1) continue;

                int count = dfs(graph, visited, malware, i);
                total += count == -1 ? 0 : count;
            }

            if (total > max) {
                max = total;
                node = n;
            }
        }

        return node;
    }

    private int dfs(int[][] graph, Set<Integer> visited, Set<Integer> malware, int n) {
        // if (!visited.add(n)) return 0; // use add to test will a little slow
        // if (malware.contains(n)) return -1;
        if (visited.contains(n)) return 0;
        if (malware.contains(n)) return -1;
        visited.add(n);

        int total = 1;
        for (int i = 0; i < graph.length; i++) {
            if (n != i && graph[n][i] == 1) {
                int count = dfs(graph, visited, malware, i);
                if (count == -1) {
                    malware.add(n);
                    return -1;
                }
                total += count;
            }
        }

        return total;
    }

    // --------------------
    //https://leetcode.com/problems/minimize-malware-spread-ii/discuss/184334/Simple-Union-Find-and-reuse-code-from-Leetcode-924
    public int minMalwareSpread2(int[][] graph, int[] initial) {
        final int n = graph.length;

        int min = n, node = -1;
        for (int m : initial) {
            final UnionFind uf = new UnionFind(n);

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (i != m && j != m && graph[i][j] == 1) uf.union(i, j);
                }
            }

            final Set<Integer> visited = new HashSet<>();
            int count = 0;
            for (int k : initial) {
                if (k == m) continue;

                int p = uf.find(k);
                if (visited.add(p)) count += uf.size[p];
            }

            if (count < min || (count == min && m < node)) {
                min = count;
                node = m;
            }
        }

        return node;
    }

    class UnionFind {
        int[] parent;
        int[] size;

        UnionFind(int n) {
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
            Arrays.fill(size, 1);
        }

        private void union(int a, int b) {
            int p = find(a), q = find(b);

            if (p != q) {
                parent[p] = q;
                size[q] += size[p];
            }
        }

        private int find(int x) {
            while (x != parent[x]) {
                parent[x] = parent[parent[x]];
                x = parent[x];
            }

            return x;
        }
    }
}
