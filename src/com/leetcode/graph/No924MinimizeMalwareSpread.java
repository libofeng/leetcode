package com.leetcode.graph;

import java.util.*;

public class No924MinimizeMalwareSpread {
    //----------------
    //
    private final static char WHITE = 0;
    private final static char GRAY = 1;
    private final static char BLACK = 2;
    private int malCount;
    private boolean[] visited;

    // Time: O(N^3), Space: O(N)
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int max = 0, node = 0;

        for (int i : initial) {
            Set<Integer> visited = new HashSet<>();
            bfs(graph, i, visited);
            if (visited.size() > max || (visited.size() == max && i < node)) {
                max = visited.size();
                node = i;
            }
        }

        return node;
    }

    // Time: O(N^2), Space: O(N)
    private void bfs(int[][] graph, int start, Set<Integer> visited) {
        final Queue<Integer> q = new LinkedList<>();
        q.offer(start);
        visited.add(start);

        while (!q.isEmpty()) {
            int n = q.poll();
            for (int i = 0; i < graph.length; i++) if (graph[n][i] == 1 && visited.add(i)) q.offer(i);
        }
    }

    // Time: O(N^2), Space: O(N)
    private void dfs(int[][] graph, int n, Set<Integer> visited) {
        if (!visited.add(n)) return;

        for (int i = 0; i < graph.length; i++) if (graph[n][i] == 1) dfs(graph, i, visited);
    }

    // -----------------
    public int minMalwareSpread2(int[][] graph, int[] initial) {
        final int n = graph.length;
        final int[] parent = new int[n], area = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;

        // union
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) if (graph[i][j] == 1) union(parent, i, j);
        }

        // count area
        for (int i = 0; i < n; i++) area[find(parent, i)]++;

        int max = 0, node = 0;
        for (int i : initial) {
            int p = find(parent, i);
            if (area[p] > max || (area[p] == max && i < node)) {
                max = area[p];
                node = i;
            }
        }

        return node;
    }

    private int find(int[] parent, int x) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    private void union(int[] parent, int a, int b) {
        parent[find(parent, a)] = find(parent, b);
    }

    // 1ms
    public int minMalwareSpread3(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        int curMaxValid = 0;
        int res = initial[0];
        boolean[] inSet = new boolean[graph.length];
        for (int i : initial) {
            inSet[i] = true;
        }
        visited = new boolean[graph.length];
        for (int i : initial) {
            char[] color = new char[graph.length];
            if (visited[i]) {
                continue;
            }
            malCount = 0;
            int curRes = dfs(graph, i, color, inSet);
            if (curRes == -1) {
                continue;
            }
            if (curRes > curMaxValid) {
                curMaxValid = curRes;
                res = i;
            }
        }
        return res;
    }

    private int dfs(int[][] graph, int row, char[] color, boolean[] initial) {
        if (color[row] != WHITE) {
            return 0;
        }
        if (initial[row]) {
            malCount++;
            if (malCount > 1) {
                return -1;
            }
        }

        color[row] = GRAY;
        int res = 1;
        for (int i = 0; i < graph.length; i++) {
            if (graph[row][i] == 0) {
                continue;
            }
            int curRes = dfs(graph, i, color, initial);
            if (curRes == -1) {
                return -1;
            }
            res += curRes;
        }
        color[row] = BLACK;
        visited[row] = true;
        return res;
    }
}
